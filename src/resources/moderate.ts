// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import { APIResource } from '../core/resource';
import { APIPromise } from '../core/api-promise';
import { RequestOptions } from '../internal/request-options';

export class Moderate extends APIResource {
  analyze(body: ModerateAnalyzeParams, options?: RequestOptions): APIPromise<ModerateAnalyzeResponse> {
    return this._client.post('/moderate', { body, ...options });
  }
}

export interface ModerateAnalyzeResponse {
  /**
   * The author of the content if your account has authors enabled. Requires you to
   * send authorId when submitting content.
   */
  author: ModerateAnalyzeResponse.Author | null;

  /**
   * Potentially modified content.
   */
  content: ModerateAnalyzeResponse.Content;

  /**
   * The evaluation of the content after running the channel policies.
   */
  evaluation: ModerateAnalyzeResponse.Evaluation;

  /**
   * Results of all insights enabled in the channel.
   */
  insights: Array<ModerateAnalyzeResponse.UnionMember0 | ModerateAnalyzeResponse.UnionMember1>;

  /**
   * Metadata about the moderation request
   */
  meta: ModerateAnalyzeResponse.Meta;

  /**
   * Results of all policies in the channel. Sorted by highest probability.
   */
  policies: Array<ModerateAnalyzeResponse.UnionMember0 | ModerateAnalyzeResponse.UnionMember1>;

  /**
   * The recommendation for the content based on the evaluation.
   */
  recommendation: ModerateAnalyzeResponse.Recommendation;

  /**
   * Policies that had errors
   */
  errors?: Array<ModerateAnalyzeResponse.Error>;
}

export namespace ModerateAnalyzeResponse {
  /**
   * The author of the content if your account has authors enabled. Requires you to
   * send authorId when submitting content.
   */
  export interface Author {
    /**
     * Author ID in Moderation API
     */
    id: string;

    /**
     * Block or suspension details, if applicable. Null if the author is enabled.
     */
    block: Author.Block | null;

    /**
     * Current author status
     */
    status: 'enabled' | 'suspended' | 'blocked';

    trust_level: Author.TrustLevel;

    /**
     * The author's ID from your system
     */
    external_id?: string | null;
  }

  export namespace Author {
    /**
     * Block or suspension details, if applicable. Null if the author is enabled.
     */
    export interface Block {
      /**
       * The moderators reason why the author was blocked or suspended.
       */
      reason?: string | null;

      /**
       * The timestamp until which they are blocked if the author is suspended.
       */
      until?: number | null;
    }

    export interface TrustLevel {
      /**
       * Author trust level (-1, 0, 1, 2, 3, or 4)
       */
      level: number;

      /**
       * True if the trust level was set manually by a moderator
       */
      manual: boolean;
    }
  }

  /**
   * Potentially modified content.
   */
  export interface Content {
    /**
     * The unique identifier for the content. Either the contentId provided by you or
     * an autogenerated ID.
     */
    id: string;

    /**
     * Whether any values have been masked.
     */
    masked: boolean;

    /**
     * The modified content, if any.
     */
    modified:
      | string
      | {
          [key: string]:
            | Content.UnionMember0
            | Content.UnionMember1
            | Content.UnionMember2
            | Content.UnionMember3;
        }
      | null;
  }

  export namespace Content {
    /**
     * Text
     */
    export interface UnionMember0 {
      /**
       * The content text
       */
      text: string;

      type: 'text';
    }

    /**
     * Image
     */
    export interface UnionMember1 {
      type: 'image';

      /**
       * A public URL of the image content
       */
      url: string;
    }

    /**
     * Video
     */
    export interface UnionMember2 {
      type: 'video';

      /**
       * A public URL of the video content
       */
      url: string;
    }

    /**
     * Audio
     */
    export interface UnionMember3 {
      type: 'audio';

      /**
       * The URL of the audio content
       */
      url: string;
    }
  }

  /**
   * The evaluation of the content after running the channel policies.
   */
  export interface Evaluation {
    /**
     * The probability that the content should be flagged.
     */
    flag_probability: number;

    /**
     * Whether the content was flagged by any policy.
     */
    flagged: boolean;

    /**
     * The severity score of the content. A higher score indicates more severe content.
     */
    severity_score: number;

    /**
     * Whether the content was flagged for Unicode spoofing.
     */
    unicode_spoofed?: boolean;
  }

  /**
   * Sentiment insight
   */
  export interface UnionMember0 {
    id: 'sentiment';

    probability: number;

    type: 'insight';

    value: 'positive' | 'neutral' | 'negative' | null;
  }

  /**
   * Language insight
   */
  export interface UnionMember1 {
    id: 'language';

    probability: number;

    type: 'insight';

    value: string | null;
  }

  /**
   * Metadata about the moderation request
   */
  export interface Meta {
    /**
     * The unique key of the channel where the content was handled. Either the channel
     * provided by you or automatically routed.
     */
    channel_key: string;

    status: 'success' | 'partial_success';

    timestamp: number;

    usage: number;

    processing_time?: string;
  }

  /**
   * Classifier policy.
   */
  export interface UnionMember0 {
    /**
     * The unique identifier for the classifier output.
     */
    id: string;

    flagged: boolean;

    probability: number;

    type: 'classifier';

    /**
     * The keys of the flagged fields if submitting an object.
     */
    flagged_fields?: Array<string>;

    labels?: Array<UnionMember0.Label>;
  }

  export namespace UnionMember0 {
    export interface Label {
      id: string;

      flagged: boolean;

      probability: number;
    }
  }

  /**
   * Entity matcher policy.
   */
  export interface UnionMember1 {
    id: string;

    flagged: boolean;

    matches: Array<UnionMember1.Match>;

    probability: number;

    type: 'entity_matcher';

    flagged_fields?: Array<string>;
  }

  export namespace UnionMember1 {
    export interface Match {
      match: string;

      probability: number;

      span: Array<unknown>;
    }
  }

  /**
   * The recommendation for the content based on the evaluation.
   */
  export interface Recommendation {
    /**
     * The action to take based on the recommendation
     */
    action: 'review' | 'allow' | 'reject';

    /**
     * The reason code for the recommendation. Can be used to display a reason to the
     * user.
     */
    reason_codes: Array<'severity_reject' | 'severity_review' | 'author_block' | 'dry_run'>;
  }

  export interface Error {
    id: string;

    message: string;
  }
}

export interface ModerateAnalyzeParams {
  /**
   * The content sent for moderation
   */
  content:
    | ModerateAnalyzeParams.UnionMember0
    | ModerateAnalyzeParams.UnionMember1
    | ModerateAnalyzeParams.UnionMember2
    | ModerateAnalyzeParams.UnionMember3
    | ModerateAnalyzeParams.UnionMember4;

  /**
   * The author of the content.
   */
  authorId?: string;

  /**
   * Provide a channel ID or key. Will use the project's default channel if not
   * provided.
   */
  channel?: string;

  /**
   * The unique ID of the content in your database.
   */
  contentId?: string;

  /**
   * For example the ID of a chat room or a post
   */
  conversationId?: string;

  /**
   * Do not store the content. The content won't enter the review queue
   */
  doNotStore?: boolean;

  /**
   * Any metadata you want to store with the content
   */
  metadata?: { [key: string]: unknown };

  /**
   * The meta type of content being moderated
   */
  metaType?: 'profile' | 'message' | 'post' | 'comment' | 'event' | 'product' | 'review' | 'other';
}

export namespace ModerateAnalyzeParams {
  /**
   * Text
   */
  export interface UnionMember0 {
    /**
     * The content text
     */
    text: string;

    type: 'text';
  }

  /**
   * Image
   */
  export interface UnionMember1 {
    type: 'image';

    /**
     * A public URL of the image content
     */
    url: string;
  }

  /**
   * Video
   */
  export interface UnionMember2 {
    type: 'video';

    /**
     * A public URL of the video content
     */
    url: string;
  }

  /**
   * Audio
   */
  export interface UnionMember3 {
    type: 'audio';

    /**
     * The URL of the audio content
     */
    url: string;
  }

  /**
   * Object
   */
  export interface UnionMember4 {
    /**
     * Values in the object. Can be mixed content types.
     */
    data: {
      [key: string]:
        | UnionMember4.UnionMember0
        | UnionMember4.UnionMember1
        | UnionMember4.UnionMember2
        | UnionMember4.UnionMember3;
    };

    type: 'object';
  }

  export namespace UnionMember4 {
    /**
     * Text
     */
    export interface UnionMember0 {
      /**
       * The content text
       */
      text: string;

      type: 'text';
    }

    /**
     * Image
     */
    export interface UnionMember1 {
      type: 'image';

      /**
       * A public URL of the image content
       */
      url: string;
    }

    /**
     * Video
     */
    export interface UnionMember2 {
      type: 'video';

      /**
       * A public URL of the video content
       */
      url: string;
    }

    /**
     * Audio
     */
    export interface UnionMember3 {
      type: 'audio';

      /**
       * The URL of the audio content
       */
      url: string;
    }
  }
}

export declare namespace Moderate {
  export {
    type ModerateAnalyzeResponse as ModerateAnalyzeResponse,
    type ModerateAnalyzeParams as ModerateAnalyzeParams,
  };
}
